<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Managed Shell Objects | ModularUIPack </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Managed Shell Objects | ModularUIPack ">
      
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../logo.svg" alt="ModularUIPack">
            ModularUIPack
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="managed-shell-objects">Managed Shell Objects</h1>

<h2 id="what-are-managed-shells">What are Managed Shells?</h2>
<p>In Unity a lot of the objects and types used in building your application have some part of them implemented in native code and often a good chunk of their data stored in native allocations that are handled by Unity's memory manager under the hood. When you can interact with these in your C# scripts via our Scripting API, you usually encounter these as types that inherit from <code>UnityEngine.Object</code>, which has an equivalent on the native side as NamedObject. For simplicity sake, we call these <strong>Unity Objects</strong> in the Memory Profiler.</p>
<p>For your scripts to be able to interact with the native objects and their memory, Unity creates managed wrapper objects for each of the objects your managed code interacts with, on demand. Their on demand creation means that, for example, a <code>BoxCollider</code> or a <code>Texture</code> that is loaded into memory without any C# code handling that loading (e.g. a scene load for an object with such a component and a <code>Renderer</code>, that references a <code>Material</code> that references the <code>Texture</code>) will just be created as a native object. If C# code then queries the <code>BoxCollider</code> component, or accesses component fields referencing the <code>Texture</code>, Unity will create their managed wrapper of the managed types <code>UnityEngine.BoxCollider</code> and <code>UnityEngine.Texture2D</code>. Once such a wrapper is created, it is cached and held onto by the native object, until it is destroyed, meaning subsequent access to it won't create a new wrapper.</p>
<h2 id="what-are-leaked-managed-shells">What are Leaked Managed Shells?</h2>
<p>The native part of a <strong>Unity Object</strong> can be destroyed, e.g. because the <strong>Scene</strong> that a <code>GameObject</code> or <code>Component</code> resides in has been unloaded, or because <code>UnityEngine.Object.Destroy()</code> is called on these. If C# code holds a reference to a <strong>Unity Object</strong>, after it has been destroyed, it keeps the managed wrapper object, its <strong>Managed Shell</strong>, in memory. Due to an overload of the <code>==</code> operator and the implicit conversion to bool for managed types inheriting from <code>UnityEngine.Object</code>, this reference may appear to be <code>== null</code> and implicitly converts to <code>false</code>. This is why these objects are sometimes called <strong>&quot;fake null&quot;</strong> objects.</p>
<h2 id="how-bad-are-leaked-manage-shells">How Bad are Leaked Manage Shells?</h2>
<p>The impact on your memory usage for holding on to these <strong>Leaked Managed Shell</strong> objects is often not huge, as the majority memory held by most of these type of objects is native memory. Most of the types in Unity's API layer, e.g. the Material in the example above, also only reference other <strong>Unity Objects</strong> through native references and only expose properties that will fetch the <strong>Managed Shell</strong> object for these when queried. A <strong>Leaked Managed Shell</strong> of a Material does therefore not hold on to the <strong>Texture Asset</strong>.</p>
<p>The same is <strong>not</strong> true for your own C# types. If e.g. your <code>MonoBehaviour</code> or <code>ScriptableObject</code> derived types hold a reference to a Texture, or managed types that may consume a lot of memory, like huge arrays or other collections, leaking a managed shell of such a type can have devastating effects on your memory usage beyond the small amount held by just the <strong>Leaked Managed Shell</strong> itself as the referenced memory will be kept from being unloaded. In case of <strong>Asset</strong> type <strong>Unity Objects</strong>, i.e. <strong>Unity Objects</strong> that are not <strong>Game Objects</strong> or their <strong>Components</strong>, such references will not only keep their Managed Shells but also their native memory from being freed up by <code>Resources.UnloadUnusedAssets()</code> or a destructive Scene unload.</p>
<h2 id="how-to-analyze-leaked-managed-shells">How to Analyze Leaked Managed Shells?</h2>
<p>If you enter <code>“(Leaked Managed Shell)”</code> into the search field of the <a href="all-memory-tab.html">All Of Memory</a> table, you can get a quick overview of all of these in your snapshot and check if any of these could be problematic. You can see what they might still hold on to via the <strong>Managed Fields</strong> data group in the <a href="selection-details-component.html">Selection Details component</a> and the <strong>References To</strong> tab of the <a href="references-component.html">Referencing component</a>.</p>
<p>If you want to ensure that a Leaked Managed Shell will be properly unloaded in the future:</p>
<ol>
<li>Go over the references shown in <strong>Referenced By</strong> tab on the <a href="references-component.html">References component</a> to find out what is referencing them.</li>
<li>Find reference to these in the C# code.</li>
<li>Make sure to manually set these references to <code>null</code>.</li>
</ol>
<p>Once that is done, the managed <strong>Garbage Collector</strong> will take care of the rest.</p>
<h2 id="counter-indicators">Counter Indicators</h2>
<p>Always nulling all references to <strong>Unity Objects</strong> can be a premature optimization. For example, if the references are confined to objects in a scene that will eventually be unloaded and there is no cumulative effect because it is only a finite set of objects, it can be safe to ignore these. That said, once a <strong>Unity Object</strong> becomes a <strong>Leaked Managed Shell</strong>, it serves no further purpose, so monitoring these type of objects via the Memory Profiler and reducing their count can be a good way to keep abreast of instances where paying closer attention to your lifetime management of these objects could be usefull to avoid surprises.</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
